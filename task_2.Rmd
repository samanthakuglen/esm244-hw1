---
title: "Task 2: Model Selection of CalCOFI Seawater Sample Data "
author: "Samantha Kuglen"
date: "1/23/2022"
output: html_document
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

library(tidyverse)
library(here)
library(AICcmodavg)
library(kableExtra)
library(equatiomatic)

```

```{r}
calcofi_data <- read_csv(here("data", "calcofi_seawater_samples.csv"))
```

### AIC Comparison of Two Linear Regression Models 
**Model 1 (f1):** Oxygen saturation as a function of water temperature, salinity, and phosphate concentration. **Model 2 (f2):** Oxygen saturation as a function of water temp, salinity, phosphate concentration, and depth.

```{r}
f1 <- o2sat ~ t_deg_c + salinity + po4u_m
mdl1 <- lm(f1, data = calcofi_data)
  
f2 <- o2sat ~ t_deg_c + salinity + po4u_m + depth_m
mdl2 <- lm(f2, data = calcofi_data)
```

Using AICc to select the better model, with a consideration the difference of AIC between the two models. 
```{r}
aic_table <- AICcmodavg::aictab(list(mdl2, mdl1)) %>% 
  rename("Model" = "Modnames")

kable(aic_table) %>% 
  kable_styling(bootstrap_options = "striped", 
                full_width = FALSE)
```

Model 1's AICc is `r round(aic_table[1, 3], 3)` while Model 2's AICc `r round(aic_table[2, 3], 3)`, with a difference in AIC's of `r round(aic_table[2, 3], 3) - round(aic_table[1, 3], 3)`. 

### Ten-fold Cross Validation of the Two Models
Using root-mean-square error as the scoring method, with the final model trained on the full dataset. 
```{r}
folds <- 10
fold_vec <- rep(1:folds, length.out = nrow(calcofi_data))

set.seed(50)

seawater_fold <- calcofi_data %>% 
  mutate(group = sample(fold_vec, size = n(), replace = FALSE))

# First fold
test_df <- seawater_fold %>% 
  filter(group == 1) 
train_df <- seawater_fold %>% 
  filter(group != 1)
```

Root-mean-square error, go in reverse order of these operations - find error (predicted actual), square it, find the average, then take the square root

```{r}
calc_rmse <- function(x, y) {
  rmse_result <- (x - y)^2 %>%  mean() %>%  sqrt()
  return(rmse_result)
}
```

Using the training dataset to create two linear regression models, based on the formulas above.
```{r}
training_mdl1 <- lm(f1, data = train_df)
training_mdl2 <- lm(f2, data = train_df)
```

Use the trained models to predict on test data 
```{r}
predict_test <- test_df %>% 
  mutate(model1 = predict(training_mdl1, test_df),
         model2 = predict(training_mdl2, test_df))

rmse_predict_test <- predict_test %>% 
  summarize(rmse_mdl1 = round(calc_rmse(model1, o2sat), digits = 3),
            rmse_mdl2 = round(calc_rmse(model2, o2sat), digits = 3)) 

kable(rmse_predict_test,
      col = c("RMSE Mod 1",
              "RMSE Mod 2"),
      caption = "Table 2: RMSE Values for Models 1 and 2") %>% 
  kable_styling(bootstrap_options = "striped", 
                full_width = FALSE)

```

Calculating over all folds and taking the average
```{r}
rmse_df <- data.frame()

for(i in 1:folds) {
  kfold_test_df <- seawater_fold %>% 
    filter(group == i)
  kfold_train_df <- seawater_fold %>% 
    filter(group != i)
  
  kfold_mdl1 <- lm(f1, data = kfold_train_df)
  kfold_mdl2 <- lm(f2, data = kfold_train_df)
  
  kfold_pred_df <- kfold_test_df %>% 
    mutate(mdl1 = predict(kfold_mdl1, kfold_test_df),
           mdl2 = predict(kfold_mdl2, .))
  
  kfold_rmse <- kfold_pred_df %>% 
    summarize(rmse_mdl1 = calc_rmse(mdl1, o2sat),
              rmse_mdl2 = calc_rmse(mdl2, o2sat))
  
  rmse_df <- bind_rows(rmse_df, kfold_rmse)
  
}

rmse_table <- rmse_df %>% 
  summarize(mean_rmse_mdl1 = mean(rmse_mdl1),
            mean_rmse_mdl2 = mean(rmse_mdl2)) 

kable(rmse_table,
      col = c("Mean RMSE Mod 1",
                      "Mean RMSE Mod 2"),
      caption = "Table 3: Average RMSE Values for Models 1 and 2") %>% 
  kable_styling(bootstrap_options = "striped", 
                full_width = FALSE)
```
We find that Model 2 has a lower RMSE than Model 1, at a value of ... vs ... The 10 cross validation informs us that Model 2 has the best fit and predicts the observed values for oxygen saturation `o2sat` with the highest level of accuracy. 
Once we have chosen the model via cross validation, we train our final model on our entire dataset. 
```{r}
final_mdl <- lm(f2, data = calcofi_data)
```
Our final model: 
`r equatiomatic::extract_eq(final_mdl, wrap = TRUE)`

Our final model with coefficients: 
`r equatiomatic::extract_eq(final_mdl, wrap = TRUE, use_coefs = TRUE)`

